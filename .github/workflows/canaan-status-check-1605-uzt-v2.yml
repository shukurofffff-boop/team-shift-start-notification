name: Canaan Status Check 16:05 UZT (v2)

on:
  schedule:
    # Intended: 16:05 UZT (UTC+5) = 11:05 UTC, Mon–Fri
    - cron: "5 11 * * 1-5"
  workflow_dispatch: {}

jobs:
  status-check:
    runs-on: ubuntu-latest
    timeout-minutes: 10

    env:
      # Telegram (already working)
      TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
      TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}

      # Zendesk
      ZENDESK_EMAIL: ${{ secrets.ZENDESK_EMAIL }}
      ZENDESK_API_TOKEN: ${{ secrets.ZENDESK_API_TOKEN }}
      ZENDESK_SUBDOMAIN: "rainpointonline"

      # AVOXI (from your screenshot)
      AVOXI_API_TOKEN: ${{ secrets.AVOXI_API_TOKEN }}
      AVOXI_BASE_URL: "https://genius.avoxi.com/api/v2"

      # Consider Zendesk "online" if last_login_at within this many minutes
      ZENDESK_ONLINE_WINDOW_MINUTES: "180"

    steps:
      - name: Install jq
        shell: bash
        run: |
          set -e
          sudo apt-get update -y
          sudo apt-get install -y jq

      - name: Check Zendesk + AVOXI and notify via Telegram if needed
        shell: bash
        run: |
          set -euo pipefail

          echo "UTC time now: $(date -u)"
          echo "Runner local time: $(date)"

          # ----------------------------
          # Agents for the 16:00 shift
          # NOTE: avoxi_ext is the EXTENSION you see in AVOXI UI (111/112)
          # This workflow will resolve the REAL AVOXI agent id automatically.
          # ----------------------------
          AGENTS_JSON='[
            {
              "name": "Tommy",
              "zendesk_email": "tommymarshmallow0@gmail.com",
              "avoxi_ext": "112",
              "telegram": "@TommyAndersonn"
            },
            {
              "name": "Mark",
              "zendesk_email": "asadbekbiznessman@gmail.com",
              "avoxi_ext": "111",
              "telegram": "@AsadbekAbduraimov"
            }
          ]'

          # ----------------------------
          # Helpers
          # ----------------------------
          url_encode() {
            # Use jq URI encoder (stable on GitHub runners)
            jq -rn --arg v "$1" '$v|@uri'
          }

          telegram_send() {
            local text="$1"
            curl -sS -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
              --data-urlencode "chat_id=${TELEGRAM_CHAT_ID}" \
              --data-urlencode "text=${text}" \
              --data-urlencode "disable_web_page_preview=true" >/dev/null
          }

          zendesk_auth_header() {
            local user="${ZENDESK_EMAIL}/token"
            local pass="${ZENDESK_API_TOKEN}"
            printf '%s' "${user}:${pass}" | base64 -w 0
          }

          http_get_json() {
            # Prints: HTTP_CODE|TMPFILE
            local url="$1"; shift
            local tmp
            tmp="$(mktemp)"
            local code
            code="$(curl -sS -o "$tmp" -w "%{http_code}" "$url" "$@")" || true
            echo "$code|$tmp"
          }

          # ----------------------------
          # Zendesk readiness (safe heuristic)
          # ----------------------------
          check_zendesk_ready() {
            local email="$1"
            local q
            q="$(url_encode "type:user email:${email}")"

            local base="https://${ZENDESK_SUBDOMAIN}.zendesk.com/api/v2"
            local auth_b64
            auth_b64="$(zendesk_auth_header)"

            local res1 code1 file1
            res1="$(http_get_json "${base}/users/search.json?query=${q}" -H "Authorization: Basic ${auth_b64}")"
            code1="${res1%%|*}"
            file1="${res1#*|}"

            if [[ "$code1" != "200" ]]; then
              rm -f "$file1"
              echo "NOT_READY|Zendesk API error (${code1})"
              return 0
            fi

            local user_id
            user_id="$(jq -r '.users[0].id // empty' "$file1")"
            rm -f "$file1"

            if [[ -z "${user_id}" ]]; then
              echo "NOT_READY|Zendesk user not found"
              return 0
            fi

            local res2 code2 file2
            res2="$(http_get_json "${base}/users/${user_id}.json" -H "Authorization: Basic ${auth_b64}")"
            code2="${res2%%|*}"
            file2="${res2#*|}"

            if [[ "$code2" != "200" ]]; then
              rm -f "$file2"
              echo "NOT_READY|Zendesk user fetch error (${code2})"
              return 0
            fi

            local last_login
            last_login="$(jq -r '.user.last_login_at // empty' "$file2")"
            rm -f "$file2"

            if [[ -z "${last_login}" || "${last_login}" == "null" ]]; then
              echo "NOT_READY|No last_login_at"
              return 0
            fi

            local now_epoch login_epoch diff_min window_min
            now_epoch="$(date -u +%s)"
            login_epoch="$(date -u -d "${last_login}" +%s 2>/dev/null || echo 0)"

            if [[ "$login_epoch" -le 0 ]]; then
              echo "NOT_READY|Invalid last_login_at"
              return 0
            fi

            diff_min=$(( (now_epoch - login_epoch) / 60 ))
            window_min="${ZENDESK_ONLINE_WINDOW_MINUTES}"

            if [[ "$diff_min" -le "$window_min" ]]; then
              echo "READY|Last login ${diff_min}m ago"
            else
              echo "NOT_READY|Last login ${diff_min}m ago"
            fi
          }

          # ----------------------------
          # AVOXI: Resolve REAL agent id (not the extension)
          # Tries several list endpoints, then matches by extension/email/name.
          # Returns: ID|MATCH_REASON
          # ----------------------------
          avoxi_resolve_agent_id() {
            local ext="$1"
            local email="$2"
            local name="$3"
            local base="${AVOXI_BASE_URL}"
            local token="${AVOXI_API_TOKEN}"

            # Candidate list endpoints (one of these will usually work)
            local endpoints=(
              "${base}/agents"
              "${base}/users"
              "${base}/agents?per_page=200"
              "${base}/users?per_page=200"
              "${base}/agents?limit=200"
              "${base}/users?limit=200"
            )

            local payload=""
            local ok="false"
            local code file

            for ep in "${endpoints[@]}"; do
              local res
              res="$(http_get_json "$ep" -H "Authorization: Bearer ${token}" -H "Accept: application/json")"
              code="${res%%|*}"
              file="${res#*|}"

              if [[ "$code" == "200" ]]; then
                payload="$(cat "$file")"
                rm -f "$file"
                ok="true"
                break
              fi
              rm -f "$file"
            done

            if [[ "$ok" != "true" ]]; then
              echo "|LIST_API_ERROR"
              return 0
            fi

            # Normalize into an array:
            # payload may be [..] or {data:[..]} or {agents:[..]} etc.
            local arr
            arr="$(jq -c '
              if type=="array" then .
              elif .data and (.data|type)=="array" then .data
              elif .agents and (.agents|type)=="array" then .agents
              elif .users and (.users|type)=="array" then .users
              else [] end
            ' <<<"$payload" 2>/dev/null || echo '[]')"

            # 1) Match by extension (most reliable)
            local id_by_ext
            id_by_ext="$(jq -r --arg ext "$ext" '
              .[]
              | select(
                  (.extension? == $ext)
                  or (.ext? == $ext)
                  or (.sip_extension? == $ext)
                  or (.phone_extension? == $ext)
                )
              | .id // empty
              | tostring
              ' <<<"$arr" | head -n 1)"

            if [[ -n "$id_by_ext" ]]; then
              echo "${id_by_ext}|MATCH_EXTENSION"
              return 0
            fi

            # 2) Match by email (if present in AVOXI payload)
            local id_by_email=""
            if [[ -n "$email" ]]; then
              id_by_email="$(jq -r --arg email "$email" '
                .[]
                | select((.email? // "" | ascii_downcase) == ($email | ascii_downcase))
                | .id // empty
                | tostring
              ' <<<"$arr" | head -n 1)"
            fi

            if [[ -n "$id_by_email" ]]; then
              echo "${id_by_email}|MATCH_EMAIL"
              return 0
            fi

            # 3) Match by name (last resort)
            local id_by_name=""
            if [[ -n "$name" ]]; then
              id_by_name="$(jq -r --arg name "$name" '
                .[]
                | select((.name? // "" | ascii_downcase) == ($name | ascii_downcase))
                | .id // empty
                | tostring
              ' <<<"$arr" | head -n 1)"
            fi

            if [[ -n "$id_by_name" ]]; then
              echo "${id_by_name}|MATCH_NAME"
              return 0
            fi

            echo "|NOT_FOUND"
          }

          # ----------------------------
          # AVOXI presence check
          # Uses resolved agent id, then calls /agents/{id}/presence
          # READY if presence contains "available" or "ready"
          # ----------------------------
          check_avoxi_ready() {
            local ext="$1"
            local email="$2"
            local name="$3"
            local base="${AVOXI_BASE_URL}"
            local token="${AVOXI_API_TOKEN}"

            local resolved
            resolved="$(avoxi_resolve_agent_id "$ext" "$email" "$name")"
            local agent_id="${resolved%%|*}"
            local reason="${resolved#*|}"

            if [[ -z "$agent_id" ]]; then
              echo "NOT_READY|AVOXI id resolve failed (${reason})"
              return 0
            fi

            local res code file
            res="$(http_get_json "${base}/agents/${agent_id}/presence" \
              -H "Authorization: Bearer ${token}" \
              -H "Accept: application/json")"
            code="${res%%|*}"
            file="${res#*|}"

            if [[ "$code" != "200" ]]; then
              rm -f "$file"
              echo "NOT_READY|AVOXI presence API error (${code})"
              return 0
            fi

            local presence
            presence="$(jq -r '.presence // .status // .state // .availability // empty' "$file" 2>/dev/null || echo "")"
            rm -f "$file"

            if [[ -z "$presence" ]]; then
              echo "NOT_READY|AVOXI presence missing (resolved:${reason})"
              return 0
            fi

            local p
            p="$(tr '[:upper:]' '[:lower:]' <<<"$presence")"

            if [[ "$p" == *"available"* || "$p" == *"ready"* ]]; then
              echo "READY|${presence} (resolved:${reason})"
            else
              echo "NOT_READY|${presence} (resolved:${reason})"
            fi
          }

          # ----------------------------
          # Main loop: one Telegram message per agent, only if needed
          # ----------------------------
          total_agents="$(jq 'length' <<<"$AGENTS_JSON")"

          for i in $(seq 0 $((total_agents - 1))); do
            name="$(jq -r ".[$i].name" <<<"$AGENTS_JSON")"
            zendesk_email="$(jq -r ".[$i].zendesk_email" <<<"$AGENTS_JSON")"
            avoxi_ext="$(jq -r ".[$i].avoxi_ext" <<<"$AGENTS_JSON")"
            tg="$(jq -r ".[$i].telegram" <<<"$AGENTS_JSON")"

            z_out="$(check_zendesk_ready "$zendesk_email")"
            a_out="$(check_avoxi_ready "$avoxi_ext" "$zendesk_email" "$name")"

            z_state="${z_out%%|*}"
            z_note="${z_out#*|}"
            a_state="${a_out%%|*}"
            a_note="${a_out#*|}"

            echo "Agent: ${name} | Zendesk: ${z_state} (${z_note}) | AVOXI: ${a_state} (${a_note})"

            if [[ "$z_state" != "READY" || "$a_state" != "READY" ]]; then
              msg="⚠️ 16:05 readiness check\n${tg}\nPlease set your status to Ready.\nZendesk: ${z_state}\nAVOXI: ${a_state}"
              telegram_send "$msg"
            fi
          done

          echo "Done."
